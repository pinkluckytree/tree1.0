### 面向对象和面向过程有什么区别？
面向对象有三大特征：封装，继承，多态

**封装**：将客观事务封装成抽象的类

**继承**：可以使用现有类的所有功能，并且对其进行扩展

**多态**：有重写，重载两种形式

重写（override）是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！

重载(overload) 是在一个类里面，**方法名字相同，而参数不同。** 返回类型可以相同也可以不同。（只需要参数不同即可）

**面向对象的编程方式使得每一个类都只做一件事。面向过程会让一个类越来越全能，就像一个管家一样做了所有的事。**

### 哈希构造方法与哈希冲突解决
哈希构造方法

1. **伪随机数法**  H(key)=random(key)
2. **平方取中**：先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。key：3546  3546^2=12574116  h(356)=5741
3. **除余**：H(key)=key % p,p<=m.(p的取值最好为素数)。
4. **直接定址法**：使用一个函数 H(key)=a*key+b;
5. **折叠法**：按哈希表地址将关键字分为几段（最后一段可以较短），然后将其相加，舍弃进位，折叠法（从左向右奇数段正序，偶数段倒序），移位法（从左向右都为正序）
6. **数字分析法**：如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。例：h(3748597089)=457，h(9846372561)=432

哈希冲突解决方法

1. **开放定址法**：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

这种方法有一个通用的再散列函数形式：
   Hi=(H(key)+di)%m,i=1,2,3,..n
   
   m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：
  （1）线性探测再散列
  （2）二次探测再散列
  （3）伪随机探测再散列


3. **再哈希法**：使用多个哈希函数
4. **链地址法（拉链法）**：冲突就放在其后，形成一个链表
5. **公共溢出区**：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表

### 接口与抽象类
1. 接口与抽象类都不能被实例化，但是可以定义接口与抽象类的引用
2. 抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。
3. 接口支持多继承，抽象类则不行
4. 接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。

### static变量在什么时候初始化？
类初始化的时候初始化类变量，实例变量的赋值是在函数或程序运行时进行

静态变量只初始化一次，但可以通过赋值的方式多次修改静态变量的值

类的生命周期：加载--**验证--*准备*--解析**--**初始化**--使用--卸载

**准备阶段**为 static 变量在方法区分配内存并初始化为默认值，使用的是方法区的内存。**初始化阶段**为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。

实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。

**类加载发生在所有实例化之前，类加载进行一次，实例化可以进行多次**

### 关于this，super
可以使用this调用该类其他的构造方法

可以使用super调用父类的构造方法，

可以使用super访问父类被子类隐藏的变量或覆盖的方法。

super()和this()均需放在构造方法内第一行。尽管可以用this调用一个构造器，但却不能调用两个。

本质上super是关键字，this是指针，this与super都不能在static环境中使用

### 关于try，catch，finally
try 可以单独与finally一起使用，释放资源

### 关于final，finally，finalize
final是一个修饰符，可以修饰变量，方法，类，修饰变量表示该变量在初始化之后不能被改变

finally是一个关键字，与try--catch一起用于异常的处理，finally一定会被执行，无论是否有发生异常

finalize方法是在对象被回收之前调用的方法，可以给对象最后一个复活的机会（调用自身），但是何时调用finalize没有保证，并且finalize（）只会被调用一次

### 关于sleep（） wait（） 四个区别
1. sleep是线程的方法，wait是object的方法
2.  sleep不会释放锁，wait会释放锁
3.  sleep方法不依赖synchronized，wait需要在synchronized同步代码块中使用否则会抛出异常
4.  sleep不需要被唤醒，wait需要

### hashcode（）？ equals() ? ==?
两个对象相等，两个对象的hashcode必然相同，反之则不一定。
基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。
引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是堆内存地址）。
对于引用类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。
### 拆箱装箱使用的函数？


### 时钟中断是哪一种中断？


### 寄存器，cache，内存速度差别
