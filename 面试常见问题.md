### 1.面向对象和面向过程有什么区别？
面向对象有三大特征：封装，继承，多态

**封装**：将客观事物封装成抽象的类

**继承**：可以使用现有类的所有功能，并且对其进行扩展

**多态**：有重写，重载两种形式

重写（override）是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！

重载(overload) 是在一个类里面，**方法名字相同，而参数不同。** 返回类型可以相同也可以不同。（只需要参数不同即可）

**面向对象的编程方式使得每一个类都只做一件事。面向过程会让一个类越来越全能，就像一个管家一样做了所有的事。**

### 2.哈希构造方法与哈希冲突解决
哈希构造方法

1. **伪随机数法**  H(key)=random(key)
2. **平方取中**：先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。key：3546  3546^2=12574116  h(356)=5741
3. **除余**：H(key)=key % p,p<=m.(p的取值最好为素数)。
4. **直接定址法**：使用一个函数 H(key)=a*key+b;
5. **折叠法**：按哈希表地址将关键字分为几段（最后一段可以较短），然后将其相加，舍弃进位，折叠法（从左向右奇数段正序，偶数段倒序），移位法（从左向右都为正序）
6. **数字分析法**：如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。例：h(3748597089)=457，h(9846372561)=432

哈希冲突解决方法

1. **开放定址法**：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

这种方法有一个通用的再散列函数形式：
   Hi=(H(key)+di)%m,i=1,2,3,..n
   
   m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：
  （1）线性探测再散列
  （2）二次探测再散列
  （3）伪随机探测再散列


3. **再哈希法**：使用多个哈希函数
4. **链地址法（拉链法）**：冲突就放在其后，形成一个链表
5. **公共溢出区**：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表

### 3.接口与抽象类
1. 接口与抽象类都不能被实例化，但是可以定义接口与抽象类的引用
2. 抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。
3. 接口支持多继承，抽象类则不行
4. 接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。

### 4.static变量在什么时候初始化？
类初始化的时候初始化类变量，实例变量的赋值是在函数或程序运行时进行

静态变量只初始化一次，但可以通过赋值的方式多次修改静态变量的值

类的生命周期：加载--**验证--*准备*--解析**--**初始化**--使用--卸载

**准备阶段**为 static 变量在方法区分配内存并初始化为默认值，使用的是方法区的内存。**初始化阶段**为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。

实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。

**类加载发生在所有实例化之前，类加载进行一次，实例化可以进行多次**

### 5.关于this，super
可以使 用this调用该类其他的构造方法

可以使用super调用父类的构造方法，

可以使用super访问父类被子类隐藏的变量或覆盖的方法。

super()和this()均需放在构造方法内第一行。尽管可以用this调用一个构造器，但却不能调用两个。

本质上super是关键字，this是指针，this与super都不能在static环境中使用

### 6.关于try，catch，finally
try 可以单独与finally一起使用，释放资源

### 7.关于final，finally，finalize
final是一个修饰符，可以修饰变量，方法，类，修饰变量表示该变量在初始化之后不能被改变

finally是一个关键字，与try--catch一起用于异常的处理，finally一定会被执行，无论是否有发生异常

finalize方法是在对象被回收之前调用的方法，可以给对象最后一个复活的机会（调用自身），但是何时调用finalize没有保证，并且finalize（）只会被调用一次

### 8.关于sleep（） wait（） 四个区别
1. sleep是线程的方法，wait是object的方法
2.  sleep不会释放锁，wait会释放锁
3.  sleep方法不依赖synchronized，wait需要在synchronized同步代码块中使用否则会抛出异常
4.  sleep不需要被唤醒，wait需要

### 9.hashcode（）？ equals() ? ==?
两个对象相等，两个对象的hashcode必然相同，反之则不一定。
基本数据类型（也称原始数据类型） ：byte,short,char,int,long,float,double,boolean。他们之间的比较，应用双等号（==）,比较的是他们的值。
引用数据类型：当他们用（==）进行比较的时候，比较的是他们在内存中的存放地址（确切的说，是堆内存地址）。
对于引用类型，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。因为每new一次，都会重新开辟堆内存空间。
### 10.JVM?JDK?JRE?
JVM:JAVA虚拟机

JRE=JVM+JAVA标准库

JDK=JRE(JVM+JAVA标准库)+开发调试诊断工具

JVM跨平台：写一个类，可以在不同的操作系统上执行，效果相同

JVM跨语言：JVM只识别字节码（也就是class文件），与语言解耦。例如Groovy，Kotlin，Scala等语言也是编译为字节码。
### 11.用户线程与内核线程
用户线程和内核线程之间有 **多对一模型**，**一对一模型**，多对多模型

多对一：多个用户线程对应一个内核线程，不需要内核态与用户态的频繁切换

一对一：一个用户线程对应一个内核线程，内核负责每个线程的调度（java使用此模型）：缺点是会引起用户态与内核态的频繁切换，内核为每个线程都映射调度实体，如果系统出现大量线程，会对系统性能有影响

### 12.对象包含哪些部分？
对象三部分：对象头，实例数据，对齐填充

对象头：1.存储对象自身的运行时数据（mark word）（包括哈希码，GC分代年龄，锁状态标志，线程持有锁等）（大小为8字节），2.类型指针（对象指向它的类元数据的指针，虚拟机可以通过这个指针来确定这个对象是哪个类的实例）（默认4字节） 3.若对象是一个数组，还会有一快用于记录数组长度的数据

实例数据：就是实例变量

对齐填充：对象整个大小应该是8字节的整数，（例如若一个对象对象头＋实例数据=33字节，需要填充为40字节）

### 13.G1与CMS 三色标记
**G1与CMS三色标记策略** （让JVM短时间发生STW，提高响应时间）

三色：黑色，灰色，白色
  
黑色：该对象已经被标记，并且该对象引用的对象也已经被标记

灰色：该对象已经被标记，但是其后还存在没有标记的引用
  
白色：该对象没有被垃圾回收器标记过，不可达
  
这两者都会有一个最终标记（或者说重新标记）的过程，是为了修正在并发标记的过程中引用发生变化导致的标记错误。
  
CMS：重新扫描：如果监测到黑色对象新增了引用，就将其置为灰色，后续扫描灰色对象，就能标记新增引用
  
G1： SATB（snapshot-at-the-beginning）（开始快照）：记录开始状态的快照，若在并发标记过程中有引用被删除，则记录下该引用，后续查看该引用是否被其他黑色对象引用，以防止漏标
### 14.拆箱装箱使用的函数？


### 15.时钟中断是哪一种中断？


### 16.寄存器，cache，内存速度差别

### 17.类加载与内部类
JVM在加载外部类的过程中，是不会加载静态内部类的，只有当内部类的属性/方法被调用时才会被加载并初始化其静态属性。静态属性被static修饰，可以保证只会被加载一次。
### 18.段式存储与页式存储
### 19.ABC类地址
A类网络的IP地址范围为：1.0.0.1－126.255.255.254；  

B类网络的IP地址范围为：128.1.0.1－191.255.255.254；  

C类网络的IP地址范围为：192.0.1.1－223.255.255.254  

具体解释： 

1．A类IP地址  

一个A类IP地址由1字节（每个字节是8位）的网络地址和3个字节主机地址组成，网络地址的最高位必须是“0”,即第一段数字范围为1～126。每个A类地址可连接16387064台主机，Internet有126个A类地址。  

2．B类IP地址  

一个B类IP地址由2个字节的网络地址和2个字节的主机地址组成，网络地址的最高位必须是“10”，即第一段数字范围为128～191。每个B类地址可连接64516台主机，Internet有16256个B类地址。  

3．C类IP地址  

一个C类地址是由3个字节的网络地址和1个字节的主机地址组成，网络地址的最高位必须是“110”，即第一段数字范围为192～223。每个C类地址可连接254台主机，Internet有2054512个C类地址。
### 20.boolean
boolean声明为成员变量时默认为false，Boolean默认为null

在方法中则会提示需要进行初始化
### 21.批处理，分时，实时操作系统特点
分时操作系统的特点：交互性，独立性，及时性，多路性

批处理：资源利用率高，成批处理
### 类型转换的一些问题
将String类型转换为int 可以使用  Integer.parseInt(String s)

将String类型转换为Integer 可以使用 Integer.valueOf(String s)

将int，Integer转换为String 可以使用String.valueOf(x);

### left join /right join /inner join
inner join(等值连接) 只返回两个表中联结字段相等的行

left join(左联接) 返回包括左表中的所有记录和右表中联结字段相等的记录

right join(右联接) 返回包括右表中的所有记录和左表中联结字段相等的记录
### TCP三次握手是否还有flood攻击存在
会有 syn_flood攻击 ：SYN-Flood攻击是当前网络上最为常见的DDoS攻击，也是最为经典的拒绝服务攻击，它利用了TCP协议实现上的一个缺陷，通过向网络服务所在端口发送大量的伪造源地址的攻击报文，就可能造成目标服务器中的半开连接队列被占满，从而阻止其他合法用户进行访问。
### this关键字是和类进行关联还是和特定对象进行关联
1. this 关键字是和特定的对象进行关联的
2. this关键字不能用在静态代码块中
3. 可以使用this关键字引用自身成员变量与方法
4. 使用this关键字代表自身类的对象
5. 使用this关键字在自身构造方法内部调用其他构造方法

### start()结束是否线程销毁
不会，start只是开启一个线程
### 16GB的空间，需要多少字节的地址
### 核心线程会被回收吗
核心线程通常不会被回收，java线程池中有一个参数allowCoreThreadTimeOut，默认为false，表示核心线程不会过期，若设置为true则会过期
### JUC 
java.util.concurrent java并发包
