### 面向对象和面向过程有什么区别？
面向对象有三大特征：封装，继承，多态

**封装**：将客观事务封装成抽象的类

**继承**：可以使用现有类的所有功能，并且对其进行扩展

**多态**：有重写，重载两种形式

重写（override）是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！

重载(overload) 是在一个类里面，**方法名字相同，而参数不同。** 返回类型可以相同也可以不同。（只需要参数不同即可）

**面向对象的编程方式使得每一个类都只做一件事。面向过程会让一个类越来越全能，就像一个管家一样做了所有的事。**

### 哈希构造方法与哈希冲突解决
哈希构造方法

1. **伪随机数法**  H(key)=random(key)
2. **平方取中**：先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。key：3546  3546^2=12574116  h(356)=5741
3. **除余**：H(key)=key % p,p<=m.(p的取值最好为素数)。
4. **直接定址法**：使用一个函数 H(key)=a*key+b;
5. **折叠法**：按哈希表地址将关键字分为几段（最后一段可以较短），然后将其相加，舍弃进位，折叠法（从左向右奇数段正序，偶数段倒序），移位法（从左向右都为正序）
6. **数字分析法**：如果事先知道关键字集合，并且每个关键字的位数比哈希表的地址码位数多时，可以从关键字中选出分布较均匀的若干位，构成哈希地址。例：h(3748597089)=457，h(9846372561)=432

哈希冲突解决方法

1. **开放定址法**：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。

这种方法有一个通用的再散列函数形式：
   Hi=(H(key)+di)%m,i=1,2,3,..n
   
   m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：
  （1）线性探测再散列
  （2）二次探测再散列
  （3）伪随机探测再散列


3. **再哈希法**：使用多个哈希函数
4. **链地址法（拉链法）**：冲突就放在其后，形成一个链表
5. **公共溢出区**：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表

### 接口与抽象类
1. 接口与抽象类都不能被实例化，但是可以定义接口与抽象类的引用
2. 抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。
3. 接口支持多继承，抽象类则不行
4. 接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。

