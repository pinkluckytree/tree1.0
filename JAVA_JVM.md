# JVM
JVM 最重要的三个组件：**类加载器，运行时数据区，执行引擎**（其实整个jvm体系结构还包括 JVM指令集，本地方法调用）

JVM 两个性能指标：**响应时间 吞吐量**

# java运行时内存区域
## 程序计数器
当前线程所执行的行号指示器 （分支，循坏，跳转，异常等都依赖于此）
## jvm虚拟机栈

虚拟机栈的每一个栈帧都包括四个部分：

局部变量表：

操作数栈

动态链接（常量池引用）

方法出口：返回地址
## 本地方法栈
与虚拟机栈类似，针对本地方法
## 堆
存放对象实例，几乎所有的对象实例都是在这里分配内存。
## 方法区
存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
## 运行时常量池（是方法区的一部分）
存放编译器生成的各种**字面量和符号引用**
## 直接内存（Dircet Memory）
并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。与NIO类有关，可以减少java堆与native堆间的来回复制
## OOM问题
定义：（内存溢出）（java内存不足）（没有空闲内存并且垃圾回收器不能提供更多的内存）
### 场景1：堆空间溢出 （java.lang.OutOfMemoryError: Java heap space）
堆空间溢出 分为两类：**内存泄露（memory leak），内存溢出（memory overflow）**
#### 内存泄漏（memory leak）
主要是程序未能释放不再使用的内存（该丢掉的没能丢掉）

常见的几种形式：

1>静态容器

2>监听器被注册后释放对象没有删除监听器

3>物理连接（例：数据库连接，网络连接）未关闭

4>内部类与外部类生命周期不一致
#### 内存溢出
内存溢出就是空间不足
### 场景2：GC开销超过限制
java.lang.OutOfMemoryError: GC overhead limit exceeded 超过98%的时间用来GC 但是只回收了不到2%的内存
### 场景3：元数据区空间不足
方法区和运行时常量池的空间不足。
### 场景4：虚拟机栈和本地方法栈溢出
虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常
## StackOverFlow
线程请求的栈深度大于虚拟机所能接受的最大深度就会抛出StackOverflow

1.递归调用太深

2.循环太多或者死循环
# JVM类加载
## 类加载介绍
类加载机制：动态加载

过程：将类的class文件读入内存，放入方法区，然后在堆区创建一个 java.lang.class对象，用来封装类在方法区的数据结构

最终产品：位于堆中的class对象

类的生命周期：加载-验证-准备-解析-初始化-使用-卸载
## 类加载器（ClassLoader）
bootstrap ClassLoader(启动类加载器)：负责加载 JVM 自身工作所需要的类。

Extension ClassLoader(扩展类加载器)：将 <JAVA_HOME>\lib\ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中

Application ClassLoader(应用程序类加载器)：负责加载用户类路径（即 classpath）上所指定的类库

自定义加载器：

### 双亲委派制度
该模型要求除了顶层的 Bootstrap ClassLoader 外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。

**一个类加载器首先将类加载请求传递给父类加载器，只有当父类加载器无法完成时才会进行加载**

好处：使得java类随着他的加载器有一个优先级的层次关系，可以防止系统内出现多份相同字节码
### 字节码文件（class文件的组成）
由两部分组成：一部分是常量池，一部分是方法字节码。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。
### java程序执行的细节
1. 编译：当编写完源文件后，程序会先被编译为class文件，java编译一个类时，如果这个类所依赖的类还没有被编译，那么就会先编译这个依赖的类，再引用
2. jvm运行，只有当程序需要用到某个类时才会加载
3. 类的实例化
### 父子类加载顺序
父类静态属性（成员变量） > 父类静态代码块 > 子类静态属性 > 子类静态代码块 > 父类非静态属性 > 父类非静态代码块 > 父类构造器 > 子类非静态属性 > 子类非静态代码块 > 子类构造器

先加载静态成员 （父->子） 再加载非静态属性（父->子）
### 静态内部类
静态内部类不持有外部类的引用，从静态这个角度上看，一切被static修饰过的属性都只与类相关，不与对象引用相关

一般的内部类持有外部类的引用，并且天然可以访问外部类的成员变量


# JVM GC(garbage collection)垃圾回收
## 如何判断一个对象应该被回收
1> 引用计数法  （但是因为循环引用的情况，这种对jvm并不适用 （a引用b，b引用a，这两种永远都不会被回收） ）

2> 可达性分析   ：GC Roots 作为起始点进行搜索，JVM 将能够到达到的对象视为存活，不可达的对象视为死亡。GC roots一般是虚拟机栈与本地方法栈引用的对象或者方法区中类静态属性引用的对象
## 引用类型（强软弱虚）
1>强引用，也就是new ，这种引用不会被回收

2>软引用，这种引用会在内存不够时被回收

  SoftReference<Object> sf=new SoftRference<Object>(obj); 

3>弱引用：一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。
  
  WeakReference<Object> wf = new WeakReference<Object>(obj);

4>虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。


  
  
