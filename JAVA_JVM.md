# JVM
JVM 最重要的三个组件：**类加载器，运行时数据区，执行引擎**（其实整个jvm体系结构还包括 JVM指令集，本地方法调用）

JVM 两个性能指标：**响应时间 吞吐量**

# java运行时内存区域
## 程序计数器
当前线程所执行的行号指示器 （分支，循坏，跳转，异常等都依赖于此）
## jvm虚拟机栈

虚拟机栈的每一个栈帧都包括四个部分：

局部变量表：

操作数栈

动态链接（常量池引用）

方法出口：返回地址
## 本地方法栈
与虚拟机栈类似，针对本地方法
## 堆
存放对象实例，几乎所有的对象实例都是在这里分配内存。
## 方法区
存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
## 运行时常量池（是方法区的一部分）
存放编译器生成的各种**字面量和符号引用**
## 直接内存（Dircet Memory）
并不是虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域。与NIO类有关，可以减少java堆与native堆间的来回复制
## OOM问题
定义：（内存溢出）（java内存不足）（没有空闲内存并且垃圾回收器不能提供更多的内存）
### 场景1：堆空间溢出 （java.lang.OutOfMemoryError: Java heap space）
堆空间溢出 分为两类：**内存泄露（memory leak），内存溢出（memory overflow）**
#### 内存泄漏（memory leak）
主要是程序未能释放不再使用的内存（该丢掉的没能丢掉）

常见的几种形式：

1>静态容器

2>监听器被注册后释放对象没有删除监听器

3>物理连接（例：数据库连接，网络连接）未关闭

4>内部类与外部类生命周期不一致
#### 内存溢出
内存溢出就是空间不足
### 场景2：GC开销超过限制
java.lang.OutOfMemoryError: GC overhead limit exceeded 超过98%的时间用来GC 但是只回收了不到2%的内存
### 场景3：元数据区空间不足
方法区和运行时常量池的空间不足。
## StackOverFlow
1.递归调用太深

2.循环太多或者死循环
