
# JVM GC(garbage collection)垃圾回收
## 如何判断一个对象应该被回收
1> 引用计数法  （但是因为循环引用的情况，这种对jvm并不适用 （a引用b，b引用a，这两种永远都不会被回收） ）

2> 可达性分析   ：GC Roots 作为起始点进行搜索，JVM 将能够到达到的对象视为存活，不可达的对象视为死亡。GC roots一般是虚拟机栈与本地方法栈引用的对象或者方法区中类静态属性引用的对象
## 引用类型（强软弱虚）
1>强引用，也就是new ，这种引用不会被回收

2>软引用，这种引用会在内存不够时被回收

  SoftReference<Object> sf=new SoftRference<Object>(obj); 

3>弱引用：一定会被垃圾收集器回收，也就是说它只能存活到下一次垃圾收集发生之前。
  
  WeakReference<Object> wf = new WeakReference<Object>(obj);

4>虚引用：为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
# 垃圾回收性能
1.吞吐量：特定的时间周期内一个应用的工作量的最大值。

2.停顿时间：因为 GC 而导致程序不能工作的时间长度。

# 垃圾回收算法
1.标记清除

2.标记整理

3.复制

在实际中，年轻代一般都使用 复制这种算法进行回收 但是并不是将内存划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survior 空间（默认为8：1：1）

4.分代算法

现在最常用的，新生代，老年代，永久代，  （新：老默认为1：2）
# 垃圾收集器
## 串行收集器（年轻代:复制，老年代：标记整理）
串行收集器采用**stop-the-world**的方式进行，内存不足时，会设置一个停顿点，待所有线程进入safepoint后，应用线程暂停，串行 GC 开始工作，采用**单线程方式**回收空间并整理内存。

serial针对年轻代

serial-old针对老年代
## 并行收集器Parallel（年轻代：复制算法，老年代：标记-整理）
并行收集器是以**吞吐量为目标**的收集器（吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)）

使用**stop-the-world** 方式，只是暂停时并行地进行垃圾收集。并行收集器年轻代采用复制算法，老年代采用标记-整理
## 并发标记清除收集器CMS（concurrent mark sweep）（老年代：标记-清除）
CMS是一种以**最短停顿时间**为目标的收集器

此处并发指的是用户线程和 GC 线程同时运行。

关键步骤。

1.初始标记 （GC roots 能直接关联的对象）

2.并发标记  （GC roots tracing）

3.重新标记（修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录） 

4.并发清除   （sweep）
## G1（标记-整理 + 复制算法）
特点：弱化分代，采用分区，无永久代

年轻代和老年代划分成多个大小相等的独立区域（Region）

通过记录每个**Region 垃圾回收时间以及回收所获得的空间**（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

步骤：

1.初始标记

2.并发标记

3.最终标记

4.删选回收
  
**G1与CMS三色标记策略** （让JVM短时间发生STW）

三色：黑色，灰色，白色
  
黑色：该对象已经被标记，并且该对象引用的对象也已经被标记

灰色：该对象已经被标记，但是其后还存在没有标记的引用
  
白色：该对象没有被垃圾回收器标记过，不可达
  
这两者都会有一个最终标记（或者说重新标记）的过程，是为了修正在并发标记的过程中引用发生变化导致的标记错误。
  
CMS：重新扫描：如果监测到黑色对象新增了引用，就将其置为灰色，后续扫描灰色对象，就能标记新增引用
  
G1： SATB（snapshot-at-the-beginning）（开始快照）：记录开始状态的快照，若在并发标记过程中有引用被删除，则记录下该引用，后续查看该引用是否被其他黑色对象引用，以防止漏标
# JVM内存分配策略
1.优先在Eden区分配

2.大对象直接进入老年代

3.年轻代到达年龄阈值后晋升

4.动态对象年龄判定（如果survivor区中相同年龄的对象占一般以上，则年龄大于等于该年龄的对象都可以晋升）

5.空间分配担保(先检查老年代最大可用的连续空间是否大于年轻代所有对象总空间,大于则一切安好可以进行minor gc，小于则需要考察 是否可以冒险 老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果不可以就需要进行一次Full GC)
# 垃圾回收发生时机
## 1.Minor GC（发生在年轻代）

当eden空间不足时发生Minor GC

a>在Eden上创建对象发现空间不足，会清理from区与Eden区 

b>Eden区清空，幸存下来的对象会进入to区同时年龄加一

c>对象年龄达到要求就进入（晋升<promotion>）老年代
  
## 2.Full GC （发生在老年代）
1.调用 System.gc():建议虚拟机进行 Full GC
  
2.老年代空间不足
  
3.方法区空间不足
  
4.Minor GC 的平均晋升空间大于老年代剩余可用空间
  
5.对象大小大于to区与老年代可用空间
  
## jvm常用参数
1. Xms 初始堆大小
2. Xmx 最大堆大小
3. Xmn 年轻代大小
