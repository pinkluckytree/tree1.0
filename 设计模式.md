## 设计模式原则
开闭原则：对扩展开放，对修改关闭

里氏代换原则：子类可以扩展父类的功能，但不能改变父类原有的功能

依赖倒转原则：高层模块不应该依赖低层模块，抽象不应该依赖细节，细节应该依赖抽象。（简单理解：应该对抽象进行编程而非对实现进行编程）

接口隔离原则：客户端不应该被迫依赖于它不适用的方法，一个类对另一个类的依赖应该建立在最小的接口上

迪米特法则：如果两个软件实体之间无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。目的是为了降低类之间的耦合度，提高模块的相对独立性。

合成复用原则：优先组合，聚合关联关系，其次考虑继承关系，
1.使用继承关系破坏了类的封装性，父类对子类透明，这种复用是一种”白箱“复用，
2.使用继承 子类与父类的耦合度高
3.使用继承限制了复用的灵活性，从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生改变，使用组合聚合复用时，可以在运行时动态进行

## 创建者模型
关注点：如何创建对象  主要特点：将对象的创建与使用分离

### 单例模式
一个单一的类，该类负责创建自己的对象，确保只有单个对象被创建，这个类提供了一种访问其唯一对象的方式，可以直接访问，不需要实例化该类的对象

设计要点： “饿汉”“懒汉”  构造器私有， 在类中创建该类对象
，提供一个公共的访问方式

### 工厂方法模式
解决一个产品簇对象的创建工作，定义一个用于创建对象的接口，让子类决定实例化哪个产品对象。工厂方法使一个产品类的实例化延迟到其工厂的子类

主要角色：1. 抽象工厂
2. 具体工厂
3. 抽象产品
4. 具体产品


### 抽象工厂模式
解决多个产品簇对象的创建工作

主要角色同工厂方法模式

### 原型模式
用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象

主要角色：抽象原型类（java中是cloneable接口）
具体原型类
访问类

浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于引用类型，仍然指向原有属性所指向的对象的内存地址（实现Cloneable接口即可）

深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有地址（使用输入输出流可以实现）

## 结构型设计模式

### 适配器模式：作为两个不兼容的接口之间的桥梁

## 行为型设计模式
### 迭代器模式
用于顺序访问集合对象的元素，不需要直到集合对象的底层表示


