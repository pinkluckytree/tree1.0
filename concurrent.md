# 并发
## 并发与并行？
这两者的关键差异是 ： 是否同时发生

## 同步（Synchronous）与异步(asynchronous)？
关键点：何时返回调用
同步：发出一个调用，在没有得到结果时不返回，一旦返回就表示有了结果

异步：发出一个调用，立即返回（并不会得到结果），调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。
## 阻塞与非阻塞？
关键点：程序在等待调用结果（返回值）的状态

阻塞：在得到调用结果之前，当前线程等待，即阻塞

非阻塞：在得到调用结果之前，当前线程不会等待
## 进程与线程
进程：进程操作系统分配资源的基本单位，进程是具有一定独立功能的**程序**关于**某个数据集合**上的一次运行活动。进程可视为一个正在运行的程序。

线程：线程时操作系统进行调度的基本单位

差别：

1>一个程序至少有一个进程，一个进程至少有一个线程

2>线程比进程划分更细，执行开销更少，**并发性**更高

3>进程有自己独立的资源，线程没有，所有线程共享所属进程的资源，具体表现到jvm中就是，几个线程共享一个堆，但是拥有自己独立的栈
## 管程（monitor）
管程等价于信号量==管程能够实现信号量，也能用信号量实现管程。

java 中synchronize关键字与wait(),notify(),notifyAll()都是管程的组成方式
## 并发的特点
核心矛盾：CPU、内存、I/O 设备存在速度差异。

为了解决这个核心矛盾，有三种措施

1>CPU 增加了缓存，以均衡与内存的速度差异；

2>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；

3>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

并发的优点：1.提高资源利用率 2.程序响应更快
## 并发的问题
### 安全性问题
并发安全需要保证三个特性
a、可见性 b、原子性 c、有序性
#### cpu缓存导致的可见性问题
一个线程对共享变量的修改，另外一个线程能够立刻看到，称为**可见性。**

对于单核来说 所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。

对于多核，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。
#### 线程切换导致的原子性问题
一个或者多个操作在 CPU 执行的过程中不被中断的特性称为**原子性**
#### 编译优化带来的有序性问题
**有序性**指的是程序按照代码的先后顺序执行。
#### 保证并发安全的方法
同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程访问。

1>阻塞同步（悲观）

2>非阻塞同步（乐观）

3>无同步

可重入代码 与 线程本地存储
### 活跃性问题
#### 死锁
四个条件：**互斥，非抢占，持有等待，循环等待**

三个解决方式：**超时释放，按序加锁，死锁检测**
#### 活锁
活锁是一个递归的情况，两个或更多的线程会不断重复一个特定的代码逻辑。预期的逻辑通常为其他线程提供机会继续支持'this'线程。

解决：谦让时，尝试等待一个随机的时间就可以了。
#### 饥饿（Starvation）
线程永远执行不到

# 线程基础
## 创建线程的三种方式
1.继承Thread类

2.实现runnable接口

3.实现callable接口
## 线程一些较为重要的方法
run（执行实体），start（启动方法），join（强制执行）

Thread.sleep():静态方法。将当前正在执行的线程休眠。**Thread.sleep 方法可能会抛出 InterruptedException，因为异常不能跨线程传播回 main 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

Thread.yield():静态方法。将当前正在执行的线程暂停，让其他线程执行。
## 守护线程（Daemon Thread）
为其他线程服务的，例：垃圾回收器

可以使用 isDaemon 方法判断线程是否为守护线程。
可以使用 setDaemon 方法设置线程为守护线程

相对的是用户线程（user Thread）
# 常见问题

## sleep、yield、join 方法有什么区别？

yield 方法会 让线程从 Running 状态转入 Runnable 状态。

当调用了 yield 方法后，只有与当前线程相同或更高优先级的Runnable 状态线程才会获得执行的机会。


sleep 方法会 让线程从 Running 状态转入 Waiting 状态。

sleep 方法需要指定等待的时间，超过等待时间后，JVM 会将线程从 Waiting 状态转入 Runnable 状态。

当调用了 sleep 方法后，无论什么优先级的线程都可以得到执行机会。

sleep 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。（wait会释放）


join 方法会 让线程从 Running 状态转入 Waiting 状态。

当调用了 join 方法后，当前线程必须等待调用 join 方法的线程结束后才能继续执行。
## 为什么 sleep 和 yield 方法是静态的？
Thread 类的 sleep 和 yield 方法是[20181794-商涛-情绪与激素.docx](https://github.com/pinkluckytree/tree1.0/files/8104158/20181794-.-.docx)
处理 Running 状态的线程。


处于非运行状态（running）的线程使用这两个方法没有意义
# 并发主要机制
1.synchronized

2.volatile

3.CAS

4.ThreadLocal（无同步）
## 锁级别（其实就是synchronized的四个状态）
1.无锁状态

2.偏向锁

偏向于第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。

3.轻量级锁

相对于传统的重量级锁而言，它 使用 CAS 操作来避免重量级锁使用互斥量的开销。

4.重量级锁
## 锁的优化方法
1.锁消除

对不可能存在共享数据的锁进行消除

2.锁粗化

虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。

3.自旋锁
互斥同步进入阻塞状态的开销都很大，应该尽量避免。 可以使用忙等待。自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。
# Volatile
轻量级synchronized

被volatile修饰的变量具有**可见性，有序性** **不具有原子性**

volatile相较synchronized成本更低，不会引起上下文切换。但是由于其不保证原子性，使用上有限制

volatile的使用需要两个条件

1.对当前变量的写操作不依赖于当前值

2.该变量没有包含在具有其他变量的表达式中

# CAS
**CAS（Compare and Swap），字面意思为比较并交换。CAS 有 3 个操作数，分别是：内存值 M，期望值 E，更新值 U。当且仅当内存值 M 和期望值 E 相等时，将内存值 M 修改为 U，否则什么都不做。

适用于线程冲突较少的情况

## CAS的问题
1.ABA问题

如果一个变量的值从A->B->A，这时CAS操作会认为该变量的值没有改变

解决方式：1.控制变量值的版本来保证 CAS 的正确性 2.使用传统的互斥同步

2.循环时间长开销大

3.只能保证一个共享变量的原子性

对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候需要用锁。
# ThreadLocal
线程本地存储 - 使用 ThreadLocal 为共享变量在每个线程中都创建了一个本地副本，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。

# 并发锁
1.可重入锁（ReentrantLock 、ReentrantReadWriteLock都是）：线程可以重复获取同一把锁。
不可重入锁：线程可以不可重复获取同一把锁。

2.公平锁与非公平锁

多线程是否按照申请锁的顺序来获取锁。synchronized就是非公平锁

3. 独享锁与共享锁

实际应用时：也称为互斥锁与读写锁。

4.悲观锁与乐观锁

是一种处理并发同步的策略。悲观锁 - 悲观锁对于并发采取悲观的态度，认为：不加锁的并发操作一定会出问题。悲观锁适合写操作频繁的场景。

5.偏向锁、轻量级锁、重量级锁

是说的锁控制粒度的粗细，控制粒度越细，阻塞开销越小，并发性也就越高。

偏向锁 - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

轻量级锁 - 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

重量级锁 - 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。

6.分段锁

是一种锁的设计方式：将**锁的对象分成多段，每段独立控制**，使得锁粒度更细，减少阻塞开销，

7.显示锁和内置锁

说的是锁的申请与释放是否由程序控制：synchronized与volite就是内置锁，锁的释放与申请是由JVM所控制的

# 线程池

定义：一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。

好处：1.降低资源消耗 2.提高相应速度 3.方便管理

## ThreadPoolExecutor
线程池最重要的类，有七个最重要的参数

1.corePoolSize 核心线程数

2.maximumPoolSize 最大线程数

3.keepAliveTime 最长等待时间

4.unit 等待时间单元

5.workQueue 等待执行的任务队列

6.threadFactory线程工厂：可以通过线程工厂给每个创建出来的线程设置更有意义的名字。

7.handler 饱和策略

例子：
```java
public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {...}
          
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(5, 10, 500, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue<Runnable>(),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.AbortPolicy());
```
## 线程池状态
1.运行状态（RUNNING）:正常运行，会处理正在进行的任务也会处理任务队列中的任务，也会接受新任务

2.关闭状态（SHUTDOWN）：会处理正在进行的任务也会处理任务队列中的任务，不会接受新任务，调用 shutdown 方法会使线程池进入到该状态。

3.停止状态（STOP）：所有均不接受，调用 shutdownNow 方法会使线程池进入到该状态。

4.整理状态（TIYDING）：如果所有的任务都已终止了，workerCount (有效线程数) 为 0，线程池进入该状态后会调用 terminated 方法进入 TERMINATED 状态。

5.已终止状态（TERMINATED）

##  execute 方法（也就是线程池运行流程）
提交任务可以使用 execute 方法 execute（new Runnable（））

1.若workerCount<corePoolSize，创建一个线程去解决任务
                            
2.若workerCount>=corePoolSize&&workerCount<maxPoolSize，并且任务队列没有满，将任务放入任务队列中

3.若workerCount>=corePoolSize&&workerCount<maxPoolSize，任务队列已经满了，创建一个新线程去解决
                                                       
4.若workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务, 默认的处理方式是直接丢弃抛异常。

## Executors
JDK 的 Executors 类中提供了几种具有代表性的线程池，这些线程池 都是基于 ThreadPoolExecutor 的定制化实现。

1.newSingleThreadExecutor：单线程线程池，可保证顺序地执行各个任务。

2.newFixedThreadPool：固定大小的线程池，每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中。

3.newCachedThreadPool：可缓存线程池，无大小限制，容易引起OOM
