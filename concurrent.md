# 并发
## 并发与并行？
这两者的关键差异是 ： 是否同时发生

## 同步（Synchronous）与异步(asynchronous)？
关键点：何时返回调用
同步：发出一个调用，在没有得到结果时不返回，一旦返回就表示有了结果

异步：发出一个调用，立即返回（并不会得到结果），调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。
## 阻塞与非阻塞？
关键点：程序在等待调用结果（返回值）的状态

阻塞：在得到调用结果之前，当前线程等待，即阻塞

非阻塞：在得到调用结果之前，当前线程不会等待
## 进程与线程
进程：进程操作系统分配资源的基本单位，进程是具有一定独立功能的**程序**关于**某个数据集合**上的一次运行活动。进程可视为一个正在运行的程序。

线程：线程时操作系统进行调度的基本单位

差别：

1>一个程序至少有一个进程，一个进程至少有一个线程

2>线程比进程划分更细，执行开销更少，**并发性**更高

3>进程有自己独立的资源，线程没有，所有线程共享所属进程的资源，具体表现到jvm中就是，几个线程共享一个堆，但是拥有自己独立的栈
## 管程（monitor）
管程等价于信号量==管程能够实现信号量，也能用信号量实现管程。

java 中synchronize关键字与wait(),notify(),notifyAll()都是管程的组成方式
## 并发的特点
核心矛盾：CPU、内存、I/O 设备存在速度差异。

为了解决这个核心矛盾，有三种措施

1>CPU 增加了缓存，以均衡与内存的速度差异；

2>操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；

3>编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

并发的优点：1.提高资源利用率 2.程序响应更快
## 并发的问题
### 安全性问题
并发安全需要保证三个特性
a、可见性 b、原子性 c、有序性
#### cpu缓存导致的可见性问题
一个线程对共享变量的修改，另外一个线程能够立刻看到，称为**可见性。**

对于单核来说 所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。

对于多核，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。
#### 线程切换导致的原子性问题
一个或者多个操作在 CPU 执行的过程中不被中断的特性称为**原子性**
#### 编译优化带来的有序性问题
**有序性**指的是程序按照代码的先后顺序执行。
#### 保证并发安全的方法
同步是指在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程访问。

1>阻塞同步（悲观）

2>非阻塞同步（乐观）

3>无同步

可重入代码 与 线程本地存储
### 活跃性问题
#### 死锁
四个条件：**互斥，非抢占，持有等待，循环等待**

三个解决方式：**超时释放，按序加锁，死锁检测**
#### 活锁
活锁是一个递归的情况，两个或更多的线程会不断重复一个特定的代码逻辑。预期的逻辑通常为其他线程提供机会继续支持'this'线程。

解决：谦让时，尝试等待一个随机的时间就可以了。
#### 饥饿（Starvation）
线程永远执行不到

# 线程基础
## 创建线程的三种方式
1.继承Thread类

2.实现runnable接口

3.实现callable接口
## 线程一些较为重要的方法
run（执行实体），start（启动方法），join（强制执行）

Thread.sleep():静态方法。将当前正在执行的线程休眠。**Thread.sleep 方法可能会抛出 InterruptedException，因为异常不能跨线程传播回 main 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。

Thread.yield():静态方法。将当前正在执行的线程暂停，让其他线程执行。
## 守护线程（Daemon Thread）
为其他线程服务的，例：垃圾回收器

可以使用 isDaemon 方法判断线程是否为守护线程。
可以使用 setDaemon 方法设置线程为守护线程

相对的是用户线程（user Thread）
## 常见问题

# sleep、yield、join 方法有什么区别？

yield 方法会 让线程从 Running 状态转入 Runnable 状态。

当调用了 yield 方法后，只有与当前线程相同或更高优先级的Runnable 状态线程才会获得执行的机会。


sleep 方法会 让线程从 Running 状态转入 Waiting 状态。

sleep 方法需要指定等待的时间，超过等待时间后，JVM 会将线程从 Waiting 状态转入 Runnable 状态。

当调用了 sleep 方法后，无论什么优先级的线程都可以得到执行机会。

sleep 方法不会释放“锁标志”，也就是说如果有 synchronized 同步块，其他线程仍然不能访问共享数据。（wait会释放）


join 方法会 让线程从 Running 状态转入 Waiting 状态。

当调用了 join 方法后，当前线程必须等待调用 join 方法的线程结束后才能继续执行。
## 为什么 sleep 和 yield 方法是静态的？
Thread 类的 sleep 和 yield 方法是[20181794-商涛-情绪与激素.docx](https://github.com/pinkluckytree/tree1.0/files/8104158/20181794-.-.docx)
处理 Running 状态的线程。

处于非运行状态（running）的线程使用这两个方法没有意义





